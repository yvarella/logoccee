from simple_salesforce import Salesforce
import streamlit as st
import altair as alt
import pandas as pd
import calendar


st.set_page_config(
    page_title="Estouro SLA",
    page_icon=":chart_with_upwards_trend:",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Adicionar o logotipo da CCEE
logo_url = "https://www.ccee.org.br/documents/20121/80354/CCEE_azul_positivo_rgb.png/2edd0967-c209-f5fe-0182-693850f20086?t=1678805129998"
st.image(logo_url, width=150, output_format='PNG')

#%% Credeciais
# Defina suas credenciais de acesso ao Salesforce
username = 'yvarella@ccee.org.br'
password = 'ys*963*963'
security_token = 'nma7B6KuV1hcksisvkbEVGI9i'

# Conecte-se ao Salesforce
sf = Salesforce(username=username, password=password, security_token=security_token)

# %% Consultas SALESFORCE

# Consulta 1 - soql_manifestacoes
soql_manifestacoes_estouro = """
    SELECT
        Id,
        AccountId,
        Origin,
        Status,
        ClosedDate,
        CreatedDate,
        Owner.Name,
        Owner.Username,
        CaseNumber,
        AssuntoDaAbertura__c,
        AssuntoDoFechamento__c,
        SubassuntoDaAbertura__c,
        SubassuntoDoFechamento__c,
        DetalheDaAbertura__c,
        DetalheDoFechamento__c,
        DataHoraDaTabulacaoDeAbertura__c,
        DataHoraPrevistaParaResolucao__c,
        ApiDaFilaDeOrigem__c,
        FuncionarioDaTabulacao__c,
        FuncionarioDeFechamento__c,
        AreaFechamentoText__c,
        AreaDeTabulacao__c,
        MotivoDoFechamento__c,
        MotivoDaAbertura__c,
        NomeDeUsuarioDoProprietario__c,
        Classificacao_final__c,
        ParentId
    FROM
        Case
        
    WHERE
        ClosedDate = THIS_YEAR
        AND Origin != 'Ativo'
        AND Status = 'Closed'
"""
#AND LinkDaPesquisa__c != null
@st.cache_data(ttl=600)
def get_manifestacoes_estouro_data():
    sf_manifestacoes_estouro = sf.query_all(soql_manifestacoes_estouro)
    df_manifestacoes_estouro = pd.DataFrame(sf_manifestacoes_estouro['records'])
    return df_manifestacoes_estouro

df_manifestacoesestouro = get_manifestacoes_estouro_data()

# Consulta 4 - soql_analise
soql_analise_estouro= """
    SELECT 
        Name,
        Analise__c,
        Manifestacao__c,
        Causa_raiz__c,
        Classificacao_do_estouro__c,
        Justificativa__c,
        Conteudo_conforme__c,
        Forma_conforme__c,
        Redaco_conforme__c,
        Resposta_insuficiente__c,
        Gerencia_participante__c,
        Gerencia_responsavel__c,
        Usuario_responsavel__c,
        Observacoes__c,
        Data_de_fechamento_do_chamado__c
                    
    FROM 
        Analise__c 
    where
        Data_de_fechamento_do_chamado__c = THIS_YEAR
        AND Analise__c = 'Estouro'
"""
@st.cache_data(ttl=600)
def get_analise_estouro_data():
    sf_analise_estouro = sf.query_all(soql_analise_estouro)
    df_analise_estouro = pd.DataFrame(sf_analise_estouro['records'])
    return df_analise_estouro

df_analise_estouro = get_analise_estouro_data()

#%% JOINS SALBESFORCE

# Renomear a coluna "Id" para "AccountId" para facilitar o join
df_analise_estouro.rename(columns={'Name': 'Codigoanalise'}, inplace=True)

# Realize o "join" entre os DataFrames df_Estouro e df_analise e df_manifestacoes usando 'Manifestacao__c' com 'Id'
df_analise_manifestcoes_estouro = df_manifestacoesestouro.merge(df_analise_estouro, left_on='Id', right_on='Manifestacao__c', how='left')


#%% Biblioteca de dados

data = []

for index, record in df_analise_manifestcoes_estouro.iterrows():
    created_date = record['CreatedDate'][:10]
    closed_date = record['ClosedDate'][:10]
    

    if record['AssuntoDoFechamento__c'] and record['AssuntoDoFechamento__c'] != record['AssuntoDaAbertura__c']:
        assuntofinal = record['AssuntoDoFechamento__c']
    else:
        assuntofinal = record['AssuntoDaAbertura__c']

    if record['SubassuntoDoFechamento__c'] and record['SubassuntoDoFechamento__c'] != record['SubassuntoDaAbertura__c']:
        subassuntofinal = record['SubassuntoDoFechamento__c']
    else:
        subassuntofinal = record['SubassuntoDaAbertura__c']

    if record['DetalheDoFechamento__c'] and record['DetalheDoFechamento__c'] != record['DetalheDaAbertura__c']:
        detalhefinal = record['DetalheDoFechamento__c']
    else:
        detalhefinal = record['DetalheDaAbertura__c']

    if record['MotivoDoFechamento__c'] and record['MotivoDoFechamento__c'] != record['MotivoDaAbertura__c']:
        motivodefechamentoreal = record['MotivoDoFechamento__c']
    else:
        motivodefechamentoreal = record['MotivoDaAbertura__c']    
    
    if motivodefechamentoreal == 'Dúvida' or record['AreaFechamentoText__c'] in ['GRES - Relacionamento Especial', 'GRPE - Relacionamento Personalizado']:
        retencaoconsiderada = 'Dúvida'
    else:
        retencaoconsiderada = motivodefechamentoreal

    if record['AreaFechamentoText__c'] in ['GEDO - Desenvolvimento e Operação', 'GEDO -  Desenvolvimento e Operação']:
        areafechamentocorrigidagedo = 'GEDO - Desenvolvimento e Operação'
    else:
        areafechamentocorrigidagedo = record['AreaFechamentoText__c']    

    if record['AreaFechamentoText__c'] in ['GRES - Relacionamento Especial', 'GRPE - Relacionamento Personalizado']:
        retenrelacionamento = True
    else:
        retenrelacionamento = False

    if record['Gerencia_responsavel__c'] in ['GRES - Relacionamento Especial', 'GRPE - Relacionamento Personalizado']:
        relacionamentoanalise = True
    else:
        relacionamentoanalise = False    
    
    tabulacaofinal= str(assuntofinal) +' | '+ str(subassuntofinal) +' | ' +str(detalhefinal)
   
    owner_name = record['Owner.Username'] if 'Owner.Username' in record else None

    created_month_year = created_date[:7]  # Extrai 'AAAA-MM'
    closed_month_year = closed_date[:7]  # Extrai 'AAAA-MM'

    data.append({
        'Id': record['Id'],
        'Origin': record['Origin'],
        'Status': record['Status'],
        'ClosedDate': record['ClosedDate'],
        'CreatedDate': record['CreatedDate'],
        'Funcionario': record['Owner']['Name'],
        'Owner.Username': record['Owner']['Username'],
        'CaseNumber': record['CaseNumber'],
        'AssuntoDaAbertura__c': record['AssuntoDaAbertura__c'],
        'AssuntoDoFechamento': record['AssuntoDoFechamento__c'],
        'SubassuntoDaAbertura__c': record['SubassuntoDaAbertura__c'],
        'SubassuntoDoFechamento': record['SubassuntoDoFechamento__c'],
        'DetalheDaAbertura__c': record['DetalheDaAbertura__c'],
        'DetalheDoFechamento': record['DetalheDoFechamento__c'],
        'DataHoraDaTabulacaoDeAbertura__c': record['DataHoraDaTabulacaoDeAbertura__c'],
        'DataHoraPrevistaParaResolucao__c': record['DataHoraPrevistaParaResolucao__c'],
        'ApiDaFilaDeOrigem__c': record['ApiDaFilaDeOrigem__c'],
        'FuncionarioDaTabulacao': record['FuncionarioDaTabulacao__c'],
        'FuncionarioDeFechamento': record['FuncionarioDeFechamento__c'],
        'Funcionarioproprietario': record['NomeDeUsuarioDoProprietario__c'],
        'AreaFechamento': areafechamentocorrigidagedo,
        'AreaTabulacao': record['AreaDeTabulacao__c'],
        'MotivoDoFechamento': record['MotivoDoFechamento__c'],
        'MotivoDaAbertura': record['MotivoDaAbertura__c'],
        'motivodefechamentoreal': motivodefechamentoreal,
        'retencaoconsiderada': retencaoconsiderada,
        'assuntofinal': assuntofinal,
        'subassuntofinal': subassuntofinal,
        'detalhefinal': detalhefinal,
        'tabulacaofinal':tabulacaofinal,
        'classificacaofinal':record['Classificacao_final__c'],
        'retencaorelacionamento': retenrelacionamento,
        'relacionamentoanalise' : relacionamentoanalise,
        'datadecriacao': created_month_year,
        'datadefechamento': closed_month_year,
        'Codigoanalise': record['Codigoanalise'],
        'TipoAnalise': record['Analise__c'],
        'Chamado Análise': record['Manifestacao__c'],
        'CausaRaiz': record['Causa_raiz__c'],
        'ClassificacaoEstouro': record['Classificacao_do_estouro__c'],
        'JustificativaEstouro': record['Justificativa__c'],
        'Conteudo': record['Conteudo_conforme__c'],
        'Forma': record['Forma_conforme__c'],
        'Redacao': record['Redaco_conforme__c'],
        'RespostaInsuficiente?': record['Resposta_insuficiente__c'],
        'GerenciaParticipante': record['Gerencia_participante__c'],
        'GerenciaResponsavel': record['Gerencia_responsavel__c'],
        'FuncionarioAnalise': record['Usuario_responsavel__c'],
        'Observacoes': record['Observacoes__c'],
        'DataFechamentoChamado': record['Data_de_fechamento_do_chamado__c']

    })

#%% Calculo Estouro CCEE

# Transformar a lista de dicionários em um DataFrame pandas
df_data = pd.DataFrame(data)

# Converta as colunas de data para o formato datetime
df_data['CreatedDate'] = pd.to_datetime(df_data['CreatedDate'])
df_data['ClosedDate'] = pd.to_datetime(df_data['ClosedDate'])

# motivoduvida = df_data[df_data['motivodefechamentoreal'].isin(['Dúvida'])]

motivoduvida = df_data[(df_data['motivodefechamentoreal'] == 'Dúvida')].copy()


filtroanalises = df_data[
(df_data['Codigoanalise'].notnull()) &
(df_data['motivodefechamentoreal'] == 'Dúvida')
]

# Agrupe por mês e conte distintos a quantidade de analises por mês
contagemanalises_mes = filtroanalises.groupby(filtroanalises['ClosedDate'].dt.to_period('M'))['Codigoanalise'].nunique().reset_index(name='DistinctCount')

# Agrupe por ano e conte distintos a quantidade de analises por ano
contagemanalises_ano = filtroanalises.groupby(filtroanalises['ClosedDate'].dt.to_period('Y'))['Codigoanalise'].nunique().reset_index(name='DistinctCount')

# Agrupe por mes e conte distintos a quantidade de chamaodos por mes
contagem_chamados_mes = motivoduvida.groupby(motivoduvida['ClosedDate'].dt.to_period('M'))['CaseNumber'].nunique().reset_index(name='DistinctCount')

# Agrupe por mes e conte distintos a quantidade de chamaodos por ano
contagem_chamados_ano = motivoduvida.groupby(motivoduvida['ClosedDate'].dt.to_period('Y'))['CaseNumber'].nunique().reset_index(name='DistinctCount')

# Calcula a razão entre o número de análises e o número de chamados para cada ano
razao_analises_chamados_ano = pd.merge(contagemanalises_ano, contagem_chamados_ano, on='ClosedDate', how='inner')
razao_analises_chamados_ano['Ratio'] = (razao_analises_chamados_ano['DistinctCount_x'] / razao_analises_chamados_ano['DistinctCount_y'])*100

# Calcula a razão entre o número de análises e o número de chamados para cada mês
razao_analises_chamados_mes = pd.merge(contagemanalises_mes, contagem_chamados_mes, on='ClosedDate', how='inner')
razao_analises_chamados_mes['Ratio'] = (razao_analises_chamados_mes['DistinctCount_x'] / razao_analises_chamados_mes['DistinctCount_y'])*100

# Reordena os meses
razao_analises_chamados_mes['ClosedDate'] = razao_analises_chamados_mes['ClosedDate'].astype(str)
razao_analises_chamados_mes['Month'] = razao_analises_chamados_mes['ClosedDate'].apply(lambda x: calendar.month_abbr[int(x[-2:])])
razao_analises_chamados_mes['Year'] = razao_analises_chamados_mes['ClosedDate'].apply(lambda x: x[:4])
razao_analises_chamados_mes['MonthYear'] = razao_analises_chamados_mes['Month'] + ' ' + razao_analises_chamados_mes['Year']
razao_analises_chamados_mes = razao_analises_chamados_mes.sort_values(by=['Year', 'ClosedDate'])

#%% Cartões estouro CCEE

# Criação da interface Streamlit com os cartões
st.write("#### Estouro SLA - CCEE")

# # Função para arredondar os valores de Estouro
# def round_Estourof(Estourof_valuer, decimal_places=1):
#     return round(Estourof_valuer, decimal_places)

# Função para obter a cor correspondente à zona do Estouro
def get_Estourof_color(Estourof_valuer):
    if Estourof_valuer > 2.5:
        return '#FF6347'
    elif Estourof_valuer == 2.5:
        return '#FFFF00'
    else:
        return '#32CD32'

# Obtendo o ano, o mês passado e o mês atual
current_date = pd.to_datetime('today')
last_month = current_date - pd.DateOffset(months=1)
current_year = current_date.year
current_month = current_date.strftime('%b')

# Filtrando os dados para obter o Estouro do ano, do mês passado e do mês atual
estouro_ano=razao_analises_chamados_ano['Ratio'].iloc[-1]


filtered_estouro_last_month = razao_analises_chamados_mes[razao_analises_chamados_mes['MonthYear'] == last_month.strftime('%b %Y')]

if not filtered_estouro_last_month.empty:
    Estouro_func_last_month = filtered_estouro_last_month['Ratio'].iloc[-1]
else:
    Estouro_func_last_month = 0  # Ou algum outro valor padrão


filtered_estouro_current_month = razao_analises_chamados_mes[razao_analises_chamados_mes['MonthYear'] == current_month + ' ' + str(current_year)]

if not filtered_estouro_current_month.empty:
    estouro_current_month = filtered_estouro_current_month['Ratio'].iloc[-1]
else:
    estouro_current_month = 0  # Ou algum outro valor padrão



# Função para arredondar os valores de Estouro
def round_Estouror(Estouro_valuer, decimal_places=1):
    return round(Estouro_valuer, decimal_places)


# Arredondando os valores de Estouro
rounded_estouro_ano = round_Estouror(estouro_ano)
rounded_Estouro_func_last_month = round_Estouror(Estouro_func_last_month)
rounded_estouro_current_month = round_Estouror(estouro_current_month)

# Obtendo as cores para os cartões
fcolor_year = get_Estourof_color(estouro_ano)
fcolor_last_month = get_Estourof_color(Estouro_func_last_month)
fcolor_current_month = get_Estourof_color(estouro_current_month)

# Estilo para os cartões
fcard_style = f"background-color: {fcolor_year}; padding: 10px; border-radius: 5px; color: white; text-align: center;"
fcard_style1 = f"background-color: {fcolor_last_month}; padding: 10px; border-radius: 5px; color: white; text-align: center;"
fcard_style2 = f"background-color: {fcolor_current_month}; padding: 10px; border-radius: 5px; color: white; text-align: center;"

col1, col2, col3 = st.columns(3)
with col1:
    # Cartão do Estouro do Ano
    st.write(f"Estouro do Ano ({current_year})")
    st.markdown(
        f'<div style="{fcard_style}">Estouro: {rounded_estouro_ano}%</div>',
        unsafe_allow_html=True
    )
with col2:
    # Cartão do Estouro do Mês Passado
    st.write(f"Estouro do Mês Passado ({last_month.strftime('%b %Y')})")
    st.markdown(
        f'<div style="{fcard_style1}">Estouro: {rounded_Estouro_func_last_month}%</div>',
        unsafe_allow_html=True
    )
with col3:
    # Cartão do Estouro do Mês Atual
    st.write(f"Estouro do Mês Atual ({current_month} {current_year})")
    st.markdown(
        f'<div style="{fcard_style2}">Estouro: {rounded_estouro_current_month}%</div>',
        unsafe_allow_html=True
    )

current_monthsidebar = razao_analises_chamados_mes['MonthYear'].iloc[-1]
current_yearsidebar = razao_analises_chamados_mes['Year'].iloc[-1]

st.sidebar.write("**Estouro SLA - CCEE**")
col1, col2 = st.sidebar.columns(2)
with col1:
    # Cartão do Estouro do Ano
    st.write(f"% de Estouro do Ano ({current_year})")
    st.markdown(
        f'<div style="{fcard_style}">Estouro: {rounded_estouro_ano}%</div>',
        unsafe_allow_html=True
    )
with col2:
        # Cartão do Estouro do Mês Atual
    st.write(f"% de Estouro do Mês Atual ({current_month} {current_year})")
    st.markdown(
        f'<div style="{fcard_style2}">Estouro: {rounded_estouro_current_month}%</div>',
        unsafe_allow_html=True
    )
st.sidebar.markdown("---")



#%% GRÁFICO Estouro CCEE 

st.write("")
# Criando o gráfico usando Altair
estouro_mes_chart = alt.Chart(razao_analises_chamados_mes).mark_line(point=True).encode(
    x=alt.X('MonthYear:N', title='Mês', sort=alt.EncodingSortField(field='ClosedDate', order='ascending')),
    y=alt.Y('Ratio', axis=alt.Axis(title='Estouro (%)')),
    color=alt.value('#1f77b4'),  # Definindo a cor das barras (azul)
    tooltip=[alt.Tooltip('MonthYear:N', title='Mês'), alt.Tooltip('Ratio:Q', title='Estouro %')]
).properties(
    width=600,
    title='Estouro por Mês do Ano'
)

# Adicione os valores de Estouro nos rótulos de dados (arredondado para um número inteiro com o símbolo "%")
estouro_mes_text = estouro_mes_chart.transform_calculate(
    Ratio_mes_texto="format(datum.Ratio, '.1f') + '%'"
).mark_text(
    align='center', baseline='bottom', dy=-5
).encode(
    x=alt.X('MonthYear:N', sort=alt.EncodingSortField(field='ClosedDate', order='ascending')),
    y=alt.Y('Ratio:Q'),
    text=alt.Text('Ratio_mes_texto:N')
)

# Adicionar a linha de meta
meta_line = alt.Chart(pd.DataFrame({'Meta': [2.5]})).mark_rule(strokeDash=[5, 5], color='red').encode(
    y=alt.Y('Meta:Q')
)

# Adicionar rótulo à linha de meta no canto direito
meta_label = alt.Chart(pd.DataFrame({'Meta': [2.5], 'Label': ['Meta (2.5%)']})).mark_text(
    align='center', baseline='bottom', dy=-5
).encode(
    y=alt.Y('Meta:Q'),
    text='Label:N'
)

st.write("")
st.altair_chart(estouro_mes_chart + estouro_mes_text + meta_line + meta_label, use_container_width=True)

#%% Estouro Relacionamento

motivoduvidarelacionamento = df_data[(df_data['motivodefechamentoreal'] == 'Dúvida') & (df_data['retencaorelacionamento'] == True)].copy()

# filtroanalises = df_data[
# (df_data['Codigoanalise'].notnull())
# ]

filtroanalises = df_data[
(df_data['Codigoanalise'].notnull()) &
(df_data['motivodefechamentoreal'] == 'Dúvida') & 
(df_data['relacionamentoanalise'] == True)
]

# Agrupe por mês e conte distintos a quantidade de analises por mês
# contagemanalises_mes = filtroanalises.groupby(filtroanalises['ClosedDate'].dt.to_period('M')).size().reset_index(name='Count')
relacionamento_analises_mes = filtroanalises.groupby(filtroanalises['ClosedDate'].dt.to_period('M'))['Codigoanalise'].nunique().reset_index(name='DistinctCount')

# Agrupe por ano e conte distintos a quantidade de analises por ano
# contagemanalises_ano = filtroanalises.groupby(filtroanalises['ClosedDate'].dt.to_period('Y')).size().reset_index(name='Count')
relacionamento_analises_ano = filtroanalises.groupby(filtroanalises['ClosedDate'].dt.to_period('Y'))['Codigoanalise'].nunique().reset_index(name='DistinctCount')

# Agrupe por mes e conte distintos a quantidade de chamaodos por mes
relacionamento_chamados_mes = motivoduvidarelacionamento.groupby(motivoduvidarelacionamento['ClosedDate'].dt.to_period('M'))['CaseNumber'].nunique().reset_index(name='DistinctCount')

# Agrupe por mes e conte distintos a quantidade de chamaodos por ano
relacionamento_chamados_ano = motivoduvidarelacionamento.groupby(motivoduvidarelacionamento['ClosedDate'].dt.to_period('Y'))['CaseNumber'].nunique().reset_index(name='DistinctCount')

# Calcula a razão entre o número de análises e o número de chamados para cada ano
razao_analises_chamados_relacionamento_ano = pd.merge(relacionamento_analises_ano, relacionamento_chamados_ano, on='ClosedDate', how='inner')
razao_analises_chamados_relacionamento_ano['Ratio'] = (razao_analises_chamados_relacionamento_ano['DistinctCount_x'] / razao_analises_chamados_relacionamento_ano['DistinctCount_y'])*100

# Calcula a razão entre o número de análises e o número de chamados para cada mês
razao_analises_chamados_relacionamento_mes = pd.merge(relacionamento_analises_mes, relacionamento_chamados_mes, on='ClosedDate', how='inner')
razao_analises_chamados_relacionamento_mes['Ratio'] = (razao_analises_chamados_relacionamento_mes['DistinctCount_x'] / razao_analises_chamados_relacionamento_mes['DistinctCount_y'])*100

# Reordena os meses
razao_analises_chamados_relacionamento_mes['ClosedDate'] = razao_analises_chamados_relacionamento_mes['ClosedDate'].astype(str)
razao_analises_chamados_relacionamento_mes['Month'] = razao_analises_chamados_relacionamento_mes['ClosedDate'].apply(lambda x: calendar.month_abbr[int(x[-2:])])
razao_analises_chamados_relacionamento_mes['Year'] = razao_analises_chamados_relacionamento_mes['ClosedDate'].apply(lambda x: x[:4])
razao_analises_chamados_relacionamento_mes['MonthYear'] = razao_analises_chamados_relacionamento_mes['Month'] + ' ' + razao_analises_chamados_relacionamento_mes['Year']
razao_analises_chamados_relacionamento_mes = razao_analises_chamados_relacionamento_mes.sort_values(by=['Year', 'ClosedDate'])

#%% Cartões estouro CCEE

# Criação da interface Streamlit com os cartões
st.write("#### Estouro SLA - Relacionamento")

# Função para obter a cor correspondente à zona do Estouro
def get_Estourof_color(Estourof_valuer):
    if Estourof_valuer > 2.5:
        return '#FF6347'
    elif Estourof_valuer == 2.5:
        return '#FFFF00'
    else:
        return '#32CD32'

# Obtendo o ano, o mês passado e o mês atual
current_date = pd.to_datetime('today')
last_month = current_date - pd.DateOffset(months=1)
current_year = current_date.year
current_month = current_date.strftime('%b')

# Filtrando os dados para obter o Estouro do ano, do mês passado e do mês atual
estourorelacionamento_ano=razao_analises_chamados_relacionamento_ano['Ratio'].iloc[-1]


filtered_estourorelacionamento_last_month = razao_analises_chamados_relacionamento_mes[razao_analises_chamados_relacionamento_mes['MonthYear'] == last_month.strftime('%b %Y')]

if not filtered_estourorelacionamento_last_month.empty:
    estourorelacionamento_func_last_month = filtered_estourorelacionamento_last_month['Ratio'].iloc[-1]
else:
    estourorelacionamento_func_last_month = 0  # Ou algum outro valor padrão


filtered_estourorelacionamento_current_month = razao_analises_chamados_relacionamento_mes[razao_analises_chamados_relacionamento_mes['MonthYear'] == current_month + ' ' + str(current_year)]

if not filtered_estourorelacionamento_current_month.empty:
    estourorelacionamento_current_month = filtered_estourorelacionamento_current_month['Ratio'].iloc[-1]
else:
    estourorelacionamento_current_month = 0  # Ou algum outro valor padrão

#%% Carttões Estouro Relacionamento

# Função para arredondar os valores de Estouro
def round_Estouror(Estouro_valuer, decimal_places=1):
    return round(Estouro_valuer, decimal_places)


# Arredondando os valores de Estouro
rounded_estourorelacionamento_ano = round_Estouror(estourorelacionamento_ano)
rounded_estourorelacionamento_last_month = round_Estouror(estourorelacionamento_func_last_month)
rounded_estourorelacionamento_current_month = round_Estouror(estourorelacionamento_current_month)

# Obtendo as cores para os cartões
fcolor_year = get_Estourof_color(estourorelacionamento_ano)
fcolor_last_month = get_Estourof_color(estourorelacionamento_func_last_month)
fcolor_current_month = get_Estourof_color(estourorelacionamento_current_month)

# Estilo para os cartões
fcard_style = f"background-color: {fcolor_year}; padding: 10px; border-radius: 5px; color: white; text-align: center;"
fcard_style1 = f"background-color: {fcolor_last_month}; padding: 10px; border-radius: 5px; color: white; text-align: center;"
fcard_style2 = f"background-color: {fcolor_current_month}; padding: 10px; border-radius: 5px; color: white; text-align: center;"

col1, col2, col3 = st.columns(3)
with col1:
    # Cartão do Estouro do Ano
    st.write(f"Estouro do Ano ({current_year})")
    st.markdown(
        f'<div style="{fcard_style}">Estouro: {rounded_estourorelacionamento_ano}%</div>',
        unsafe_allow_html=True
    )
with col2:
    # Cartão do Estouro do Mês Passado
    st.write(f"Estouro do Mês Passado ({last_month.strftime('%b %Y')})")
    st.markdown(
        f'<div style="{fcard_style1}">Estouro: {rounded_estourorelacionamento_last_month}%</div>',
        unsafe_allow_html=True
    )
with col3:
    # Cartão do Estouro do Mês Atual
    st.write(f"Estouro do Mês Atual ({current_month} {current_year})")
    st.markdown(
        f'<div style="{fcard_style2}">Estouro: {rounded_estourorelacionamento_current_month}%</div>',
        unsafe_allow_html=True
    )

st.sidebar.write("**Estouro SLA - Relacionamento**")
col1, col2 = st.sidebar.columns(2)
with col1:
    # Cartão do Estouro do Ano
    st.write(f"% de Estouro do Ano ({current_year})")
    st.markdown(
        f'<div style="{fcard_style}">Estouro: {rounded_estourorelacionamento_ano}%</div>',
        unsafe_allow_html=True
    )
with col2:
    # Cartão do Estouro do Mês Atual
    st.write(f"% de Estouro do Mês Atual ({current_month} {current_year})")
    st.markdown(
        f'<div style="{fcard_style2}">Estouro: {rounded_estourorelacionamento_current_month}%</div>',
        unsafe_allow_html=True
    )

st.sidebar.markdown("---")

#%% GRÁFICO Estouro Relacionamento

st.write("")
# Criando o gráfico usando Altair
estourorelacionamento_mes_chart = alt.Chart(razao_analises_chamados_relacionamento_mes).mark_line(point=True).encode(
    x=alt.X('MonthYear:N', title='Mês', sort=alt.EncodingSortField(field='ClosedDate', order='ascending')),
    y=alt.Y('Ratio', axis=alt.Axis(title='Estouro (%)')),
    color=alt.value('#1f77b4'),  # Definindo a cor das barras (azul)
    tooltip=[alt.Tooltip('MonthYear:N', title='Mês'), alt.Tooltip('Ratio:Q', title='Estouro %')]
).properties(
    width=600,
    title='Estouro por Mês do Ano'
)

# Adicione os valores de Estouro nos rótulos de dados (arredondado para um número inteiro com o símbolo "%")
estourorelacionamento_mes_text = estourorelacionamento_mes_chart.transform_calculate(
    Ratio_mes_texto="format(datum.Ratio, '.1f') + '%'"
).mark_text(
    align='center', baseline='bottom', dy=-5
).encode(
    x=alt.X('MonthYear:N', sort=alt.EncodingSortField(field='ClosedDate', order='ascending')),
    y=alt.Y('Ratio:Q'),
    text=alt.Text('Ratio_mes_texto:N')
)


st.write("")
st.altair_chart(estourorelacionamento_mes_chart + estourorelacionamento_mes_text + meta_line + meta_label, use_container_width=True)



#%% Estouro 3 Nível

motivoduvidanivel3 = df_data[(df_data['motivodefechamentoreal'] == 'Dúvida') & (df_data['retencaorelacionamento'] != True)].copy()


filtroanalises = df_data[
(df_data['Codigoanalise'].notnull()) &
(df_data['motivodefechamentoreal'] == 'Dúvida') & 
(df_data['relacionamentoanalise'] != True)
]

# Agrupe por mês e conte distintos a quantidade de analises por mês
# contagemanalises_mes = filtroanalises.groupby(filtroanalises['ClosedDate'].dt.to_period('M')).size().reset_index(name='Count')
nivel3_analises_mes = filtroanalises.groupby(filtroanalises['ClosedDate'].dt.to_period('M'))['Codigoanalise'].nunique().reset_index(name='DistinctCount')

# Agrupe por ano e conte distintos a quantidade de analises por ano
# contagemanalises_ano = filtroanalises.groupby(filtroanalises['ClosedDate'].dt.to_period('Y')).size().reset_index(name='Count')
nivel3_analises_ano = filtroanalises.groupby(filtroanalises['ClosedDate'].dt.to_period('Y'))['Codigoanalise'].nunique().reset_index(name='DistinctCount')

# Agrupe por mes e conte distintos a quantidade de chamaodos por mes
nivel3_chamados_mes = motivoduvidanivel3.groupby(motivoduvidanivel3['ClosedDate'].dt.to_period('M'))['CaseNumber'].nunique().reset_index(name='DistinctCount')

# Agrupe por mes e conte distintos a quantidade de chamaodos por ano
nivel3_chamados_ano = motivoduvidanivel3.groupby(motivoduvidanivel3['ClosedDate'].dt.to_period('Y'))['CaseNumber'].nunique().reset_index(name='DistinctCount')

# Calcula a razão entre o número de análises e o número de chamados para cada ano
razao_analises_chamados_nivel3_ano = pd.merge(nivel3_analises_ano, nivel3_chamados_ano, on='ClosedDate', how='inner')
razao_analises_chamados_nivel3_ano['Ratio'] = (razao_analises_chamados_nivel3_ano['DistinctCount_x'] / razao_analises_chamados_nivel3_ano['DistinctCount_y'])*100

# Calcula a razão entre o número de análises e o número de chamados para cada mês
razao_analises_chamados_nivel3_mes = pd.merge(nivel3_analises_mes, nivel3_chamados_mes, on='ClosedDate', how='inner')
razao_analises_chamados_nivel3_mes['Ratio'] = (razao_analises_chamados_nivel3_mes['DistinctCount_x'] / razao_analises_chamados_nivel3_mes['DistinctCount_y'])*100

# Reordena os meses
razao_analises_chamados_nivel3_mes['ClosedDate'] = razao_analises_chamados_nivel3_mes['ClosedDate'].astype(str)
razao_analises_chamados_nivel3_mes['Month'] = razao_analises_chamados_nivel3_mes['ClosedDate'].apply(lambda x: calendar.month_abbr[int(x[-2:])])
razao_analises_chamados_nivel3_mes['Year'] = razao_analises_chamados_nivel3_mes['ClosedDate'].apply(lambda x: x[:4])
razao_analises_chamados_nivel3_mes['MonthYear'] = razao_analises_chamados_nivel3_mes['Month'] + ' ' + razao_analises_chamados_nivel3_mes['Year']
razao_analises_chamados_nivel3_mes = razao_analises_chamados_nivel3_mes.sort_values(by=['Year', 'ClosedDate'])

#%% Cartões estouro CCEE 3 nivel

# Criação da interface Streamlit com os cartões
st.write("#### Estouro SLA - 3º Nível")

# Função para obter a cor correspondente à zona do Estouro
def get_Estourof_color(Estourof_valuer):
    if Estourof_valuer > 2.5:
        return '#FF6347'
    elif Estourof_valuer == 2.5:
        return '#FFFF00'
    else:
        return '#32CD32'

# Obtendo o ano, o mês passado e o mês atual
current_date = pd.to_datetime('today')
last_month = current_date - pd.DateOffset(months=1)
current_year = current_date.year
current_month = current_date.strftime('%b')

# Filtrando os dados para obter o Estouro do ano, do mês passado e do mês atual
estouronivel3_ano=razao_analises_chamados_nivel3_ano['Ratio'].iloc[-1]


filtered_estouronivel3_last_month = razao_analises_chamados_nivel3_mes[razao_analises_chamados_nivel3_mes['MonthYear'] == last_month.strftime('%b %Y')]

if not filtered_estouronivel3_last_month.empty:
    estouronivel3_func_last_month = filtered_estouronivel3_last_month['Ratio'].iloc[-1]
else:
    estouronivel3_func_last_month = 0  # Ou algum outro valor padrão


filtered_estouronivel3_current_month = razao_analises_chamados_nivel3_mes[razao_analises_chamados_nivel3_mes['MonthYear'] == current_month + ' ' + str(current_year)]

if not filtered_estouronivel3_current_month.empty:
    estouronivel3_current_month = filtered_estouronivel3_current_month['Ratio'].iloc[-1]
else:
    estouronivel3_current_month = 0  # Ou algum outro valor padrão


# Função para arredondar os valores de Estouro
def round_Estouror(Estouro_valuer, decimal_places=1):
    return round(Estouro_valuer, decimal_places)


# Arredondando os valores de Estouro
rounded_estouronivel3_ano = round_Estouror(estouronivel3_ano)
rounded_estouronivel3_last_month = round_Estouror(estouronivel3_func_last_month)
rounded_estouronivel3_current_month = round_Estouror(estouronivel3_current_month)

# Obtendo as cores para os cartões
fcolor_year = get_Estourof_color(estouronivel3_ano)
fcolor_last_month = get_Estourof_color(estouronivel3_func_last_month)
fcolor_current_month = get_Estourof_color(estouronivel3_current_month)

# Estilo para os cartões
fcard_style = f"background-color: {fcolor_year}; padding: 10px; border-radius: 5px; color: white; text-align: center;"
fcard_style1 = f"background-color: {fcolor_last_month}; padding: 10px; border-radius: 5px; color: white; text-align: center;"
fcard_style2 = f"background-color: {fcolor_current_month}; padding: 10px; border-radius: 5px; color: white; text-align: center;"

col1, col2, col3 = st.columns(3)
with col1:
    # Cartão do Estouro do Ano
    st.write(f"Estouro do Ano ({current_year})")
    st.markdown(
        f'<div style="{fcard_style}">Estouro: {rounded_estouronivel3_ano}%</div>',
        unsafe_allow_html=True
    )
with col2:
    # Cartão do Estouro do Mês Passado
    st.write(f"Estouro do Mês Passado ({last_month.strftime('%b %Y')})")
    st.markdown(
        f'<div style="{fcard_style1}">Estouro: {rounded_estouronivel3_last_month}%</div>',
        unsafe_allow_html=True
    )
with col3:
    # Cartão do Estouro do Mês Atual
    st.write(f"Estouro do Mês Atual ({current_month} {current_year})")
    st.markdown(
        f'<div style="{fcard_style2}">Estouro: {rounded_estouronivel3_current_month}%</div>',
        unsafe_allow_html=True
    )


st.sidebar.write("**Estouro SLA - 3º Nível**")
col1, col2 = st.sidebar.columns(2)
with col1:
    # Cartão do Estouro do Ano
    st.write(f"% de Estouro do Ano ({current_year})")
    st.markdown(
        f'<div style="{fcard_style}">Estouro: {rounded_estouronivel3_ano}%</div>',
        unsafe_allow_html=True
    )
with col2:
    # Cartão do Estouro do Mês Atual
    st.write(f"% de Estouro do Mês Atual ({current_month} {current_year})")
    st.markdown(
        f'<div style="{fcard_style2}">Estouro: {rounded_estouronivel3_current_month}%</div>',
        unsafe_allow_html=True
    )

st.sidebar.markdown("---")

#%% GRÁFICO Estouro nivel3

st.write("")
# Criando o gráfico usando Altair
estouronivel3_mes_chart = alt.Chart(razao_analises_chamados_nivel3_mes).mark_line(point=True).encode(
    x=alt.X('MonthYear:N', title='Mês', sort=alt.EncodingSortField(field='ClosedDate', order='ascending')),
    y=alt.Y('Ratio', axis=alt.Axis(title='Estouro (%)')),
    color=alt.value('#1f77b4'),  # Definindo a cor das barras (azul)
    tooltip=[alt.Tooltip('MonthYear:N', title='Mês'), alt.Tooltip('Ratio:Q', title='Estouro %')]
).properties(
    width=600,
    title='Estouro por Mês do Ano'
)

# Adicione os valores de Estouro nos rótulos de dados (arredondado para um número inteiro com o símbolo "%")
estouronivel3_mes_text = estouronivel3_mes_chart.transform_calculate(
    Ratio_mes_texto="format(datum.Ratio, '.1f') + '%'"
).mark_text(
    align='center', baseline='bottom', dy=-5
).encode(
    x=alt.X('MonthYear:N', sort=alt.EncodingSortField(field='ClosedDate', order='ascending')),
    y=alt.Y('Ratio:Q'),
    text=alt.Text('Ratio_mes_texto:N')
)


st.write("")
st.altair_chart(estouronivel3_mes_chart + estouronivel3_mes_text + meta_line + meta_label, use_container_width=True)

#%% Tabela estouro por área

# Função para carregar os dados e criar a tabela
def criar_tabelaestouroporarea():
    # Carregar dados e realizar as operações necessárias
    # ...

    # Agrupar por 'GerenciaResponsavel' e calcular contagens de estouros para cada área de gerência
    estouros_agrupados = filtroanalises.groupby('GerenciaResponsavel').agg(
        Estouros=('Codigoanalise', 'nunique')
    ).reset_index()

    # Agrupar por 'AreaFechamento' e calcular contagens de chamados fechados para cada área de fechamento
    chamados_agrupados = motivoduvida.groupby('AreaFechamento').agg(
        ChamadosFechados=('ClosedDate', 'count')
    ).reset_index()

    # Mesclar os dados agrupados de estouros com as taxas por ano
    dados_finais = pd.merge(chamados_agrupados, estouros_agrupados, left_on='AreaFechamento', right_on='GerenciaResponsavel', how='left')

    # Calcular a porcentagem de casos de estouro
    dados_finais['% Chamados Estourados'] = (dados_finais['Estouros'] / dados_finais['ChamadosFechados']) * 100


    
    # Preencher valores nulos com 0 e formatar a coluna % Chamados Estourados
    dados_finais = dados_finais.fillna(0)
    dados_finais['% Chamados Estourados'] = dados_finais['% Chamados Estourados'].round(1)
    dados_finais['% Chamados Estourados'] = dados_finais['% Chamados Estourados'].apply(lambda x: f'{x:.1f}%')

    # Selecionar as colunas desejadas para a tabela final
    tabelaestouroporarea = dados_finais[['AreaFechamento', 'ChamadosFechados', 'Estouros', '% Chamados Estourados']]

    return tabelaestouroporarea

tabelaestouroporarea = criar_tabelaestouroporarea()
# Renomear a coluna 'tabulacaofinal' para 'Classificação'
tabelaestouroporarea = tabelaestouroporarea.rename(columns={'% Chamados Estourados': '% Estouros'})

# # Chamar a função e exibir a tabela usando o Streamlit
# st.write(f'#### Estouro por Área ({current_year})')
# tabelaestouroporarea = criar_tabelaestouroporarea()
# st.dataframe(tabelaestouroporarea)

#%% Tabela estouro por justificativa

# Função para carregar os dados e criar a tabela
def criar_tabelaestouroportipo():
    # Carregar dados e realizar as operações necessárias
    # ...

    # # Extrair o mês e o ano de 'ClosedDate' e criar a coluna 'Mês e Ano'
    # motivoduvida['Mês e Ano'] = motivoduvida['ClosedDate'].dt.strftime('%Y-%m')
    # filtroanalises['Mês e Ano'] = filtroanalises['ClosedDate'].dt.strftime('%Y-%m')

    estouros_agrupados = filtroanalises.groupby(['ClassificacaoEstouro']).agg(
        Estouros=('Codigoanalise', 'nunique')
    ).reset_index()

    chamados_agrupados = motivoduvida.groupby(['ClassificacaoEstouro']).agg(
        ChamadosFechados=('ClosedDate', 'count')
    ).reset_index()

    # # Mesclar os dados agrupados de estouros com as taxas por ano
    # dados_finais = pd.merge(chamados_agrupados, estouros_agrupados, left_on='AreaFechamento', right_on='GerenciaResponsavel', how='left')

    # Mesclar os dados agrupados de estouros com as taxas por ano
    dados_finais = pd.merge(chamados_agrupados, estouros_agrupados, on='ClassificacaoEstouro', how='left')
    
    # Calcular a porcentagem de casos de estouro
    dados_finais['% Chamados Estourados'] = (dados_finais['Estouros'] / dados_finais['ChamadosFechados']) * 100
    
    # Preencher valores nulos com 0 e formatar a coluna % Chamados Estourados
    dados_finais = dados_finais.fillna(0)
    dados_finais['% Chamados Estourados'] = dados_finais['% Chamados Estourados'].round(1)
    dados_finais['% Chamados Estourados'] = dados_finais['% Chamados Estourados'].apply(lambda x: f'{x:.1f}%')

    # Selecionar as colunas desejadas para a tabela final
    tabelaestouroportipo = dados_finais[['ClassificacaoEstouro','ChamadosFechados', 'Estouros', '% Chamados Estourados']]

    return tabelaestouroportipo

# Chamar a função e exibir a tabela usando o Streamlit
tabelaestouroportipo = criar_tabelaestouroportipo()

# Remover a coluna 'GerenciaResponsavel'
tabelaestouroportipo = tabelaestouroportipo.drop(columns=['ChamadosFechados'])

# Renomear a coluna 'tabulacaofinal' para 'Classificação'
tabelaestouroportipo = tabelaestouroportipo.rename(columns={'% Chamados Estourados': '% Estouros'})

col1, col2 = st.columns([2,1])
with col1:
    # Chamar a função e exibir a tabela usando o Streamlit
    st.write(f'#### Estouro por Área ({current_year})')
    st.dataframe(tabelaestouroporarea)
with col2:
    #Exibe Tabela estouro por justificativa
    st.write(f'#### Tipos de Estouros ({current_year})')
    st.dataframe(tabelaestouroportipo)




#%% Tabela estouro por área mês

# Função para carregar os dados e criar a tabela
def criar_tabelaestouroporareames():
    # Carregar dados e realizar as operações necessárias
    # ...

    # Agrupar por 'GerenciaResponsavel' e calcular contagens de estouros para cada área de gerência e mês do ano
    estouros_agrupados_mes = filtroanalises.groupby(['GerenciaResponsavel', df_data['ClosedDate'].dt.to_period('M')]).agg(
        Estouros=('Codigoanalise', 'nunique')
    ).reset_index()

    # Agrupar por 'AreaFechamento' e calcular contagens de chamados fechados para cada área de fechamento e mês do ano
    chamados_agrupados_mes = motivoduvida.groupby(['AreaFechamento', df_data['ClosedDate'].dt.to_period('M')]).agg(
        ChamadosFechados=('ClosedDate', 'count')
    ).reset_index()

    # Mesclar os dados agrupados de estouros com as taxas por mês do ano
    dados_finais_mes = pd.merge(chamados_agrupados_mes, estouros_agrupados_mes, left_on=['AreaFechamento', 'ClosedDate'], right_on=['GerenciaResponsavel', 'ClosedDate'], how='left')

    # Calcular a porcentagem de casos de estouro
    dados_finais_mes['% Chamados Estourados'] = (dados_finais_mes['Estouros'] / dados_finais_mes['ChamadosFechados']) * 100

    # Preencher valores nulos com 0 nas colunas relevantes
    colunas_para_preencher = ['Estouros', 'ChamadosFechados', '% Chamados Estourados']
    dados_finais_mes[colunas_para_preencher] = dados_finais_mes[colunas_para_preencher].fillna(0)
    dados_finais_mes['Estouros'] = dados_finais_mes['Estouros'].fillna(0)
    dados_finais_mes['ChamadosFechados'] = dados_finais_mes['ChamadosFechados'].fillna(0)
    dados_finais_mes['% Chamados Estourados'] = dados_finais_mes['% Chamados Estourados'].fillna(0)
    dados_finais_mes['% Chamados Estourados'] = dados_finais_mes['% Chamados Estourados'].round(1)
    dados_finais_mes['% Chamados Estourados'] = dados_finais_mes['% Chamados Estourados'].apply(lambda x: f'{x:.1f}%')

    # Pivotar a tabela para exibir os meses do ano como colunas
    tabela_pivotada = dados_finais_mes.pivot(index='AreaFechamento', columns='ClosedDate', values='% Chamados Estourados')
    tabela_pivotada = tabela_pivotada.rename_axis(None, axis=1)  # Remover nome da coluna de índice

    return tabela_pivotada

# Função para aplicar as cores às células da tabela
def apply_colors(val):
    try:
        val = float(val[:-1])  # Remover o símbolo de porcentagem e converter para float
        if val > 2.5:
            return 'background-color: #FF6347'
        elif val == 2.5:
            return 'background-color: #FFFF00'
        else:
            return 'background-color: #32CD32'
    except:
        return ''

# Chamar a função e exibir a tabela usando o Streamlit
st.write(f'#### Estouro por Área e Mês do Ano')
tabelaestouroporareames = criar_tabelaestouroporareames()
tabelaestouroporareames_styled = tabelaestouroporareames.style.applymap(apply_colors)

# Adicionar 'Estouros' e 'ChamadosFechados' às colunas da tabela estilizada
tabelaestouroporareames_styled_with_values = tabelaestouroporareames_styled.set_properties(**{
    'Estouros': 'color: black; font-weight: bold',
    'ChamadosFechados': 'color: black; font-weight: bold',
})

st.dataframe(tabelaestouroporareames_styled_with_values, width=0)



#%% FILTRO ÁREA
st.markdown("---")

# Criar uma lista de áreas únicas para seleção
unique_areas = sorted(df_data['AreaFechamento'].unique())

selected_area = st.selectbox('Selecione a Área:', unique_areas)


motivoduvidaarea = df_data[(df_data['motivodefechamentoreal'] == 'Dúvida') & (df_data['AreaFechamento'] == selected_area)].copy()


filtroanalisesarea = df_data[
(df_data['Codigoanalise'].notnull()) &
(df_data['motivodefechamentoreal'] == 'Dúvida') & 
(df_data['GerenciaResponsavel'] == selected_area)
]

# Agrupe por mês e conte distintos a quantidade de analises por mês
# contagemanalises_mes = filtroanalisesarea.groupby(filtroanalisesarea['ClosedDate'].dt.to_period('M')).size().reset_index(name='Count')
area_analises_mes = filtroanalisesarea.groupby(filtroanalisesarea['ClosedDate'].dt.to_period('M'))['Codigoanalise'].nunique().reset_index(name='DistinctCount')

# Agrupe por ano e conte distintos a quantidade de analises por ano
# contagemanalises_ano = filtroanalisesarea.groupby(filtroanalisesarea['ClosedDate'].dt.to_period('Y')).size().reset_index(name='Count')
area_analises_ano = filtroanalisesarea.groupby(filtroanalisesarea['ClosedDate'].dt.to_period('Y'))['Codigoanalise'].nunique().reset_index(name='DistinctCount')

# Agrupe por mes e conte distintos a quantidade de chamaodos por mes
area_chamados_mes = motivoduvidaarea.groupby(motivoduvidaarea['ClosedDate'].dt.to_period('M'))['CaseNumber'].nunique().reset_index(name='DistinctCount')

# Agrupe por mes e conte distintos a quantidade de chamaodos por ano
area_chamados_ano = motivoduvidaarea.groupby(motivoduvidaarea['ClosedDate'].dt.to_period('Y'))['CaseNumber'].nunique().reset_index(name='DistinctCount')

# Calcula a razão entre o número de análises e o número de chamados para cada ano
razao_analises_chamados_area_ano = pd.merge(area_analises_ano, area_chamados_ano, on='ClosedDate', how='inner')
razao_analises_chamados_area_ano['Ratio'] = (razao_analises_chamados_area_ano['DistinctCount_x'] / razao_analises_chamados_area_ano['DistinctCount_y'])*100

# Calcula a razão entre o número de análises e o número de chamados para cada mês
razao_analises_chamados_area_mes = pd.merge(area_analises_mes, area_chamados_mes, on='ClosedDate', how='inner')
razao_analises_chamados_area_mes['Ratio'] = (razao_analises_chamados_area_mes['DistinctCount_x'] / razao_analises_chamados_area_mes['DistinctCount_y'])*100

# Reordena os meses
razao_analises_chamados_area_mes['ClosedDate'] = razao_analises_chamados_area_mes['ClosedDate'].astype(str)
razao_analises_chamados_area_mes['Month'] = razao_analises_chamados_area_mes['ClosedDate'].apply(lambda x: calendar.month_abbr[int(x[-2:])])
razao_analises_chamados_area_mes['Year'] = razao_analises_chamados_area_mes['ClosedDate'].apply(lambda x: x[:4])
razao_analises_chamados_area_mes['MonthYear'] = razao_analises_chamados_area_mes['Month'] + ' ' + razao_analises_chamados_area_mes['Year']
razao_analises_chamados_area_mes = razao_analises_chamados_area_mes.sort_values(by=['Year', 'ClosedDate'])

#%% Cartões estouro CCEE

# Criação da interface Streamlit com os cartões
st.write(f"#### Estouro SLA - {selected_area}")

# Função para obter a cor correspondente à zona do Estouro
def get_Estourof_color(Estourof_valuer):
    if Estourof_valuer > 2.5:
        return '#FF6347'
    elif Estourof_valuer == 2.5:
        return '#FFFF00'
    else:
        return '#32CD32'

# Obtendo o ano, o mês passado e o mês atual
current_date = pd.to_datetime('today')
last_month = current_date - pd.DateOffset(months=1)
current_year = current_date.year
current_month = current_date.strftime('%b')

# Filtrando os dados para obter o Estouro do ano, do mês passado e do mês atual
estouroarea_ano=razao_analises_chamados_area_ano['Ratio'].iloc[-1]


filtered_estouroarea_last_month = razao_analises_chamados_area_mes[razao_analises_chamados_area_mes['MonthYear'] == last_month.strftime('%b %Y')]

if not filtered_estouroarea_last_month.empty:
    estouroarea_func_last_month = filtered_estouroarea_last_month['Ratio'].iloc[-1]
else:
    estouroarea_func_last_month = 0  # Ou algum outro valor padrão


filtered_estouroarea_current_month = razao_analises_chamados_area_mes[razao_analises_chamados_area_mes['MonthYear'] == current_month + ' ' + str(current_year)]

if not filtered_estouroarea_current_month.empty:
    estouroarea_current_month = filtered_estouroarea_current_month['Ratio'].iloc[-1]
else:
    estouroarea_current_month = 0  # Ou algum outro valor padrão


# Função para arredondar os valores de Estouro
def round_Estouror(Estouro_valuer, decimal_places=1):
    return round(Estouro_valuer, decimal_places)


# Arredondando os valores de Estouro
rounded_estouroarea_ano = round_Estouror(estouroarea_ano)
rounded_estouroarea_last_month = round_Estouror(estouroarea_func_last_month)
rounded_estouroarea_current_month = round_Estouror(estouroarea_current_month)

# Obtendo as cores para os cartões
fcolor_year = get_Estourof_color(estouroarea_ano)
fcolor_last_month = get_Estourof_color(estouroarea_func_last_month)
fcolor_current_month = get_Estourof_color(estouroarea_current_month)

# Estilo para os cartões
fcard_style = f"background-color: {fcolor_year}; padding: 10px; border-radius: 5px; color: white; text-align: center;"
fcard_style1 = f"background-color: {fcolor_last_month}; padding: 10px; border-radius: 5px; color: white; text-align: center;"
fcard_style2 = f"background-color: {fcolor_current_month}; padding: 10px; border-radius: 5px; color: white; text-align: center;"

col1, col2, col3 = st.columns(3)
with col1:
    # Cartão do Estouro do Ano
    st.write(f"Estouro do Ano ({current_year})")
    st.markdown(
        f'<div style="{fcard_style}">Estouro: {rounded_estouroarea_ano}%</div>',
        unsafe_allow_html=True
    )
with col2:
    # Cartão do Estouro do Mês Passado
    st.write(f"Estouro do Mês Passado ({last_month.strftime('%b %Y')})")
    st.markdown(
        f'<div style="{fcard_style1}">Estouro: {rounded_estouroarea_last_month}%</div>',
        unsafe_allow_html=True
    )
with col3:
    # Cartão do Estouro do Mês Atual
    st.write(f"Estouro do Mês Atual ({current_month} {current_year})")
    st.markdown(
        f'<div style="{fcard_style2}">Estouro: {rounded_estouroarea_current_month}%</div>',
        unsafe_allow_html=True
    )

#%% GRÁFICO Estouro area

st.write("")
# Criando o gráfico usando Altair
estouroarea_mes_chart = alt.Chart(razao_analises_chamados_area_mes).mark_line(point=True).encode(
    x=alt.X('MonthYear:N', title='Mês', sort=alt.EncodingSortField(field='ClosedDate', order='ascending')),
    y=alt.Y('Ratio', axis=alt.Axis(title='Estouro (%)')),
    color=alt.value('#1f77b4'),  # Definindo a cor das barras (azul)
    tooltip=[alt.Tooltip('MonthYear:N', title='Mês'), alt.Tooltip('Ratio:Q', title='Estouro %')]
).properties(
    width=600,
    title='Estouro por Mês do Ano'
)

# Adicione os valores de Estouro nos rótulos de dados (arredondado para um número inteiro com o símbolo "%")
estouroarea_mes_text = estouroarea_mes_chart.transform_calculate(
    Ratio_mes_texto="format(datum.Ratio, '.1f') + '%'"
).mark_text(
    align='center', baseline='bottom', dy=-5
).encode(
    x=alt.X('MonthYear:N', sort=alt.EncodingSortField(field='ClosedDate', order='ascending')),
    y=alt.Y('Ratio:Q'),
    text=alt.Text('Ratio_mes_texto:N')
)


st.write("")
st.altair_chart(estouroarea_mes_chart + estouroarea_mes_text + meta_line + meta_label, use_container_width=True)

#%% Tabela estouros área individual

# Função para carregar os dados e criar a tabela
def criar_tabelaestouroporareaindividual():
    # Carregar dados e realizar as operações necessárias
    # ...

    # Extrair o mês e o ano de 'ClosedDate' e criar a coluna 'Mês e Ano'
    motivoduvidaarea['Mês e Ano'] = motivoduvidaarea['ClosedDate'].dt.strftime('%Y-%m')
    filtroanalisesarea['Mês e Ano'] = filtroanalisesarea['ClosedDate'].dt.strftime('%Y-%m')

    estouros_agrupados = filtroanalisesarea.groupby(['GerenciaResponsavel', 'Mês e Ano']).agg(
        Estouros=('Codigoanalise', 'nunique')
    ).reset_index()

    chamados_agrupados = motivoduvidaarea.groupby(['Mês e Ano', 'AreaFechamento']).agg(
        ChamadosFechados=('ClosedDate', 'count')
    ).reset_index()

    # Mesclar os dados agrupados de estouros com as taxas por ano
    dados_finais = pd.merge(chamados_agrupados, estouros_agrupados, left_on='AreaFechamento', right_on='GerenciaResponsavel', how='left')

    # Mesclar os dados agrupados de estouros com as taxas por ano
    dados_finais = pd.merge(chamados_agrupados, estouros_agrupados, on='Mês e Ano', how='left')
    
    # Calcular a porcentagem de casos de estouro
    dados_finais['% Chamados Estourados'] = (dados_finais['Estouros'] / dados_finais['ChamadosFechados']) * 100
    
    # Preencher valores nulos com 0 e formatar a coluna % Chamados Estourados
    dados_finais = dados_finais.fillna(0)
    dados_finais['% Chamados Estourados'] = dados_finais['% Chamados Estourados'].round(1)
    dados_finais['% Chamados Estourados'] = dados_finais['% Chamados Estourados'].apply(lambda x: f'{x:.1f}%')

    # Selecionar as colunas desejadas para a tabela final
    # tabelaestouroporarea = dados_finais[['AreaFechamento', 'ChamadosFechados', 'Estouros', '% Chamados Estourados']]
    tabelaestouroporareaindividual = dados_finais[['GerenciaResponsavel', 'Mês e Ano', 'ChamadosFechados', 'Estouros', '% Chamados Estourados']]

    return tabelaestouroporareaindividual

# Chamar a função e exibir a tabela usando o Streamlit
tabelaestouroporareaindividual = criar_tabelaestouroporareaindividual()

# Remover a coluna 'GerenciaResponsavel'
tabelaestouroporareaindividual = tabelaestouroporareaindividual.drop(columns=['GerenciaResponsavel'])



#%% Tabela estouro por justificativa

# Função para carregar os dados e criar a tabela
def criar_tabelaestouroportipoinividual():
    # Carregar dados e realizar as operações necessárias
    # ...

    # Extrair o mês e o ano de 'ClosedDate' e criar a coluna 'Mês e Ano'
    motivoduvidaarea['Mês e Ano'] = motivoduvidaarea['ClosedDate'].dt.strftime('%Y-%m')
    filtroanalisesarea['Mês e Ano'] = filtroanalisesarea['ClosedDate'].dt.strftime('%Y-%m')

    estouros_agrupados = filtroanalisesarea.groupby(['GerenciaResponsavel', 'ClassificacaoEstouro','Mês e Ano']).agg(
        Estouros=('Codigoanalise', 'nunique')
    ).reset_index()

    chamados_agrupados = motivoduvidaarea.groupby(['Mês e Ano', 'AreaFechamento']).agg(
        ChamadosFechados=('ClosedDate', 'count')
    ).reset_index()

    # Mesclar os dados agrupados de estouros com as taxas por ano
    dados_finais = pd.merge(chamados_agrupados, estouros_agrupados, left_on='AreaFechamento', right_on='GerenciaResponsavel', how='left')

    # Mesclar os dados agrupados de estouros com as taxas por ano
    dados_finais = pd.merge(chamados_agrupados, estouros_agrupados, on='Mês e Ano', how='left')
    
    # Calcular a porcentagem de casos de estouro
    dados_finais['% Chamados Estourados'] = (dados_finais['Estouros'] / dados_finais['ChamadosFechados']) * 100
    
    # Preencher valores nulos com 0 e formatar a coluna % Chamados Estourados
    dados_finais = dados_finais.fillna(0)
    dados_finais['% Chamados Estourados'] = dados_finais['% Chamados Estourados'].round(1)
    dados_finais['% Chamados Estourados'] = dados_finais['% Chamados Estourados'].apply(lambda x: f'{x:.1f}%')

    # Selecionar as colunas desejadas para a tabela final
    tabelaestouroportipoindividual = dados_finais[['GerenciaResponsavel', 'ClassificacaoEstouro', 'Mês e Ano', 'ChamadosFechados', 'Estouros', '% Chamados Estourados']]

    return tabelaestouroportipoindividual

# Chamar a função e exibir a tabela usando o Streamlit
tabelaestouroportipoindividual = criar_tabelaestouroportipoinividual()
# Defina a ordem desejada das colunas
column_order = ['Mês e Ano', 'ClassificacaoEstouro', '% Chamados Estourados']
# Remover a coluna 'GerenciaResponsavel'
tabelaestouroportipoindividual = tabelaestouroportipoindividual.drop(columns=['GerenciaResponsavel','ChamadosFechados'])
# Reordenar as colunas conforme a lista column_order
tabelaestouroportipoindividual = tabelaestouroportipoindividual[column_order]

col1, col2 = st.columns(2)
with col1:
    #Exibe Tabela estouros área individual
    st.write(f'#### Detalhes Estouros por Mês e Ano')
    st.dataframe(tabelaestouroporareaindividual)
with col2:
    #Exibe Tabela estouro por justificativa
    st.write(f'#### Tipos de Estouros por Mês e Ano')
    st.dataframe(tabelaestouroportipoindividual)
